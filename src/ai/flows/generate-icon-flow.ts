'use server';
/**
 * @fileOverview An AI flow for generating simple icons based on textual descriptions.
 *
 * - generateIcon - A function that attempts to generate an icon image.
 * - GenerateIconInput - The input type for the generateIcon function.
 * - GenerateIconOutput - The return type for the generateIcon function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateIconInputSchema = z.object({
  description: z.string().describe('A short description of the icon to generate (e.g., "a simple heart icon", "blue folder icon"). Keep it concise for best results.'),
});
export type GenerateIconInput = z.infer<typeof GenerateIconInputSchema>;

const GenerateIconOutputSchema = z.object({
  iconDataUri: z.string().describe("The generated icon image as a data URI (e.g., 'data:image/png;base64,...'). Null if generation failed."),
  feedback: z.string().optional().describe("Feedback or reason if icon generation failed or has issues."),
});
export type GenerateIconOutput = z.infer<typeof GenerateIconOutputSchema>;

export async function generateIcon(input: GenerateIconInput): Promise<GenerateIconOutput> {
  return generateIconFlow(input);
}

// This flow directly uses the ai.generate capability for image generation.
// A separate prompt object is not strictly necessary if the logic is simple.
const generateIconFlow = ai.defineFlow(
  {
    name: 'generateIconFlow',
    inputSchema: GenerateIconInputSchema,
    outputSchema: GenerateIconOutputSchema,
  },
  async (input: GenerateIconInput) => {
    if (!input.description.trim()) {
      return { iconDataUri: "", feedback: "Description cannot be empty." };
    }

    try {
      const {media, finishReason} = await ai.generate({
        model: 'googleai/gemini-2.0-flash-exp', // Must use this model for image generation
        prompt: `Generate a simple, flat, minimalist icon representing: ${input.description}. The icon should be suitable for a web interface, with clear lines and preferably on a transparent or white background if possible. Avoid complex details or text.`,
        config: {
          responseModalities: ['IMAGE', 'TEXT'], // Must request IMAGE; TEXT is good for feedback
          // Adjust safety settings if needed, though less critical for icons
          safetySettings: [
            { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
            { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
            { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
            { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
          ],
          // You might add candidateCount: 1 if you only want one attempt.
        },
        // output: { format: "json" } // Not typically used for image generation direct calls like this
      });
      
      if (finishReason === "BLOCKED" || finishReason === "ERROR" || finishReason === "UNKNOWN" || finishReason === "OTHER"){
         return { iconDataUri: "", feedback: `Icon generation failed. Reason: ${finishReason}. The model may have refused the request due to safety filters or other issues.` };
      }

      if (media && media.url) {
        // Gemini 2.0 Flash sometimes returns WEBP, ensure client can handle or convert.
        // For icons, PNG is generally preferred. The model often returns PNG for simple requests.
        // We assume the data URI is directly usable.
        return { iconDataUri: media.url };
      } else {
        return { iconDataUri: "", feedback: "No image was generated by the model." };
      }
    } catch (error: any) {
      console.error("Error generating icon:", error);
      return { iconDataUri: "", feedback: `An error occurred: ${error.message || 'Unknown error'}` };
    }
  }
);
