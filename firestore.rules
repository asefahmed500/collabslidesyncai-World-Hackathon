
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Check if user is the creator of the presentation
    function isPresentationCreator(presentationData) {
      return isAuthenticated() && presentationData.creatorId == request.auth.uid;
    }

    // Check if user has specific access role to the presentation
    function hasPresentationAccess(presentationData, role) {
      return isAuthenticated() && presentationData.access[request.auth.uid] == role;
    }

    // Check if user has at least viewer access
    function canViewPresentation(presentationData) {
      return isPresentationCreator(presentationData) ||
             (presentationData.access != null && request.auth.uid in presentationData.access &&
              (presentationData.access[request.auth.uid] == 'owner' ||
               presentationData.access[request.auth.uid] == 'editor' ||
               presentationData.access[request.auth.uid] == 'viewer'));
    }

    // Check if user can edit the presentation
    function canEditPresentation(presentationData) {
      return isPresentationCreator(presentationData) ||
             hasPresentationAccess(presentationData, 'owner') ||
             hasPresentationAccess(presentationData, 'editor');
    }

    // Admin check - placeholder, ideally use custom claims
    // For simplicity now, let's assume an admin might have a specific role or be creator
    // This should be replaced with a robust admin check in production (e.g., custom claims or admin user collection)
    function isAdmin() {
      // Placeholder: In a real app, use custom claims `request.auth.token.isAppAdmin == true`
      // Or check against a list of admin UIDs.
      // For now, we'll allow creators to act as "admins" for their own content for some ops
      // and rely on backend API routes to enforce true platform admin actions.
      return isAuthenticated(); // Simplified for now, backend validates true admin actions
    }

    match /presentations/{presentationId} {
      allow read: if resource.data.deleted == false &&
                     ( (resource.data.settings.isPublic == true && resource.data.moderationStatus != 'taken_down') ||
                       (isAuthenticated() && canViewPresentation(resource.data) && resource.data.moderationStatus != 'taken_down') ||
                       (isAuthenticated() && isAdmin()) // Admins can bypass taken_down for review
                     );

      allow create: if isAuthenticated(); // Further validation in backend (e.g. user has a team)

      // Update: Allow if user is creator, or has owner/editor access in the access map
      // Specific field updates (like settings, access map itself, moderationStatus) should be validated carefully.
      // Deeper validation of incoming data (request.resource.data) is crucial here.
      allow update: if isAuthenticated() && canEditPresentation(resource.data) && resource.data.moderationStatus != 'taken_down'
                    // Admins can update moderation status or if it's taken down
                    || (isAuthenticated() && isAdmin() && (request.resource.data.moderationStatus != resource.data.moderationStatus || resource.data.moderationStatus == 'taken_down'));

      // Delete (soft delete): Allow creator or those with owner access.
      // Permanent delete should be an admin-only backend operation.
      allow delete: if isAuthenticated() && (isPresentationCreator(resource.data) || hasPresentationAccess(resource.data, 'owner'));
    }

    match /presentationActivities/{activityId} {
      allow read: if isAuthenticated(); // Or more specific rules based on presentation access
      allow create: if isAuthenticated(); // Typically created by backend functions/server actions
      allow update, delete: if false; // Activities should be immutable
    }

    match /assets/{assetId} {
      allow create: if isAuthenticated() && request.resource.data.uploaderId == request.auth.uid && request.resource.data.teamId != null;
      allow read: if isAuthenticated() && get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data.members[request.auth.uid] != null; // Simplistic, assumes teams collection or needs custom claim for teamId
      allow delete: if isAuthenticated() && (resource.data.uploaderId == request.auth.uid || isAdmin()); // Or team admin
    }

    match /notifications/{notificationId} {
      allow read, update: if isAuthenticated() && resource.data.userId == request.auth.uid; // User can read/update (mark as read) their own notifications
      allow create: if isAuthenticated(); // Notifications are created by the system/server actions
      allow delete: if false; // Users generally don't delete notifications this way
    }

    match /feedbackSubmissions/{submissionId} {
      allow create: if true; // Allow anyone (even unauthenticated for initial submission) or isAuthenticated()
      allow read, update, delete: if isAuthenticated() && isAdmin(); // Only admins can manage feedback
    }

    // If you have a 'users' collection in Firestore for user-specific app settings (not profile data which is in MongoDB)
    // match /users/{userId} {
    //   allow read, write: if isUser(userId);
    // }
  }
}

    